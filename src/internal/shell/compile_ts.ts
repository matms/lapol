// General utilities for compiling LaPoL modules from Typescript to Javascript.

import { exec as nodeExec } from "child_process";
import { promisify } from "util";
import { LaPath } from "../la_path";
import { type as os_type } from "os";
import * as fs from "fs";
import { readFile, writeFile, canAccess } from "../utils";
import { LapolError } from "../errors";

const fsStat = promisify(fs.stat);
const exec = promisify(nodeExec);

const TSCONFIG_FILE_NAME = "tsconfig.json";

/** Generates a `tsconfig.json` file in the directory containing `targetFile`.
 * This `tsconfig.json` file is meant to allow compilation of Typescript LaPoL modules.
 *
 * Throws an error if a `tsconfig.json` file already exists, unless it was also autogenerated by
 * this function, in which case, it will be overridden.
 */
async function makeTsCfg(targetFile: LaPath): Promise<void> {
    const sep = targetFile.sep;
    const p = targetFile.parsed;

    const target = new LaPath(`${p.dir}${sep}${TSCONFIG_FILE_NAME}`);

    let content =
        "// <LaPoL> This file is autogenerated. Do Not Modify (don't modify this comment, either)!\n";

    // Guard against overriding an existing file accidentally.
    if (await canAccess(target)) {
        const currContent = await readFile(target);

        if (!currContent.startsWith(content))
            throw new LapolError(
                `There is already a tsconfig.json file in the target directory (${target.fullPath}), and it doesn't look autogenerated.`
            );
    }

    content += JSON.stringify({
        compilerOptions: {
            target: "es6",
            module: "commonjs",
            rootDir: p.dir,
            outDir: `${p.dir}${sep}.lapol${sep}build`,
            baseUrl: `${__dirname}${sep}..${sep}..${sep}..`, // This = the folder "build"
            /*
            paths: {
                "lapol/*": ["*"],
            },
            */
        },
    });

    await writeFile(target, content);
}

function compileOutFilePath(modFile: LaPath): LaPath {
    const p = modFile.parsed;
    const sep = modFile.sep;
    return new LaPath(`${p.dir}${sep}.lapol${sep}build${sep}${p.name}.js`);
}

/** Returns a promise evaluating to true iff the file `modPath` needs to be compiled. */
async function needCompile(modFile: LaPath): Promise<boolean> {
    const s = await fsStat(modFile.fullPath, { bigint: true });
    const srcMTimeNs = s.mtimeNs;
    const p = modFile.parsed;
    const sep = modFile.sep;
    try {
        const c = await readFile(
            new LaPath(`${p.dir}${sep}.lapol${sep}build_meta${sep}${p.name}.build_src_time`)
        );
        if (srcMTimeNs.toString() === c.trim()) {
            return false;
        } else {
            return true;
        }
    } catch (error) {
        // If can't read metadata, it probably doesn't exist, so recompile.
        return true;
    }
}

/** Compiles (if necessary) the typescript file `modFile`.
 * Returns a promise, which evaluates a LaPath referring to the outputted `.js` file.
 *
 * Side effects:
 * - Creates a `tsconfig.json` file, if one doesn't exist already. If a non-LaPoL generated tsconfig
 *   file exists in the containing directory, throw an error.
 * - Creates a .lapol folder, and subfolder build and build_meta.
 *
 * Compiles if the corresponding js file does not exist, or if the typescript file has been changed
 * since the last compile (according to file modification timestamp).
 */
export async function jsModFromTs(modFile: LaPath): Promise<LaPath> {
    const tPre = Date.now();
    if (!(await needCompile(modFile))) {
        const tPost = Date.now();
        console.log(
            `<jsModFromTs> Timestamp matches, NOT recompiling "${modFile.fullPath}". Took ${
                tPost - tPre
            } millis to verify this.`
        );
        return compileOutFilePath(modFile);
    }
    console.log(
        `\n<jsModFromTs> Compiling Typescript module "${modFile.fullPath}" to Javascript\n`
    );

    const s = await fsStat(modFile.fullPath, { bigint: true });
    const srcMTimeNs = s.mtimeNs;
    const sep = modFile.sep;
    const p = modFile.parsed;

    try {
        const t0 = Date.now();

        await makeTsCfg(modFile);

        console.log("Cool.");

        const cmd2 = `tsc -p "${p.dir}${sep}${TSCONFIG_FILE_NAME}"`;

        console.log(`<jsModFromTs> cmd = {${cmd2}}`);
        const { stdout, stderr } = await exec(cmd2, {
            cwd: p.dir,
            shell: os_type() === "Windows_NT" ? "powershell.exe" : undefined,
        });

        const t1 = Date.now();
        await writeFile(
            new LaPath(`${p.dir}${sep}.lapol${sep}build_meta${sep}${p.name}.build_src_time`),
            `${srcMTimeNs.toString()}`
        );
        const t2 = Date.now();

        console.log(
            `<jsModFromTs> Finished compiling TS module after ${t1 - t0} (+ ${
                t2 - t1
            } extra) millis (path ${modFile.fullPath})`
        );
        console.log(`<jsModFromTs> Total time: ${t2 - tPre}`);
        if (stdout !== "" || stderr !== "") {
            console.log(
                `<jsModFromTs> "${modFile.fullPath}", exec outputted something! Notably:\n\tstdout: ${stdout}\n\tstderr:${stderr}`
            );
        }
    } catch (error) {
        console.log(`<jsModFromTs> ERROR!!! error: ${JSON.stringify(error)}`);
        throw new LapolError(
            `<jsModFromTs> Error compiling "${modFile.fullPath}": ${JSON.stringify(error)}`
        );
    }
    return compileOutFilePath(modFile);
}
